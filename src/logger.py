import datetime
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Boolean, Float
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import os
from sqlalchemy import inspect
from sqlalchemy.orm import scoped_session, sessionmaker


STUDENT_RESPONSE_TABLE = 'student_responses'
GENERATED_EXERCISE_TABLE = 'generated_exercise'
ENGLISH_LTL_TABLE = 'english_ltl_pairs'
SENTENCE_PAIR_RATING_TABLE = 'sentence_pair_ratings'


def get_db_uri():
    ### If running in heroku, I want to use the postgres database
    if 'DATABASE_URL' in os.environ:
        db_uri = os.environ['DATABASE_URL']
        if db_uri.startswith("postgres://"):
            db_uri = db_uri.replace("postgres://", "postgresql://", 1)
        print(f"Using HEROKU PROVIDED database at {db_uri}, which was generated by replacing uri at {os.environ['DATABASE_URL']}")
        return db_uri
    else:   
        # Get the directory of the current script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Create a path to the database file
        db_dir = os.path.join(script_dir, 'db')

        # Create directory db_dir if it doesn't exist
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)


        db_path = os.path.join(db_dir, 'database.db')
        print("Using file-based database at ", db_path)
        return f'sqlite:///{db_path}'

Base = declarative_base()


class StudentResponse(Base):
    __tablename__ = STUDENT_RESPONSE_TABLE
    id = Column(Integer, primary_key=True)
    user_id = Column(String)
    timestamp = Column(DateTime)
    misconception = Column(String)
    question_text = Column(String)
    question_options = Column(String)
    correct_answer = Column(Boolean)
    question_type = Column(String)
    mp_class = Column(String)
    exercise = Column(String)
    course = Column(String, default="")


class GeneratedExercise(Base):
    __tablename__ = GENERATED_EXERCISE_TABLE
    id = Column(Integer, primary_key=True)
    user_id = Column(String)
    timestamp = Column(DateTime)
    exercise_data = Column(String)
    complexity = Column(Integer)
    exerciseName = Column(String)


class EnglishLTLRating(Base):
    __tablename__ = ENGLISH_LTL_TABLE
    id = Column(Integer, primary_key=True)
    english = Column(String)
    ltl = Column(String)
    comments = Column(String)
    user_id = Column(String)
    timestamp = Column(DateTime, default=datetime.datetime.utcnow)


class SentencePairRating(Base):
    __tablename__ = SENTENCE_PAIR_RATING_TABLE
    id = Column(Integer, primary_key=True)
    user_id = Column(String, index=True)
    dataset = Column(String, index=True)  # "near" or "far"
    row_index = Column(Integer, index=True)
    base_english = Column(String)
    mutant_english = Column(String)
    base_ltl = Column(String)
    mutant_ltl = Column(String)
    misconception = Column(String)
    likert_rating = Column(Integer)
    awkward_flag = Column(Boolean, default=False)
    awkward_notes = Column(String)
    closest_distance = Column(Float)
    max_distance = Column(Float)
    avg_distance = Column(Float)
    num_mutants = Column(Integer)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)


class Logger:
    def __init__(self):

        db_uri = get_db_uri()
        self.engine = create_engine(db_uri)
        Base.metadata.create_all(self.engine)
        self.session_factory = sessionmaker(bind=self.engine, expire_on_commit=True)
        self.Session = scoped_session(self.session_factory)

        self.inspector = inspect(self.engine)
        if STUDENT_RESPONSE_TABLE not in self.inspector.get_table_names():
            Base.metadata.tables[STUDENT_RESPONSE_TABLE].create(self.engine)

        if GENERATED_EXERCISE_TABLE not in self.inspector.get_table_names():
            Base.metadata.tables[GENERATED_EXERCISE_TABLE].create(self.engine)

        if SENTENCE_PAIR_RATING_TABLE not in self.inspector.get_table_names():
            Base.metadata.tables[SENTENCE_PAIR_RATING_TABLE].create(self.engine)

    def record(self, log):
        with self.Session() as session:
            print("Recording log")
            session.add(log)
            session.commit()

    
    def logStudentResponse(self, userId, misconceptions, question_text, question_options, correct_answer, questiontype, mp_class, exercise, course):

        if not isinstance(userId, str):
            raise ValueError("userId should be a string")
        if not isinstance(question_text, str):
            raise ValueError("question_text should be a string")
        if not isinstance(question_options, str):
            raise ValueError("question_options should be a string")
        if not isinstance(correct_answer, bool):
            raise ValueError("correct_answer should be a boolean")
        if not isinstance(questiontype, str):
            raise ValueError("questiontype should be a string")
        if not isinstance(mp_class, str):
            raise ValueError("mp_class should be a string")
        if not isinstance(exercise, str):
            raise ValueError("exercise should be a string")
        
        if not isinstance(course, str):
            raise ValueError("course should be a string")

        ## We still want to log the response if there are no misconceptions
        if misconceptions == None or len(misconceptions) == 0:
            log = StudentResponse(user_id=userId, timestamp=datetime.datetime.now(), 
                                  misconception="", question_text=question_text, question_options=question_options, correct_answer=correct_answer,
                                  question_type=questiontype, mp_class=mp_class, exercise=exercise, course=course)
            self.record(log)



        for misconception in misconceptions:
            if not isinstance(misconception, str):
                raise ValueError("misconception should be a string")

            log = StudentResponse(user_id=userId, timestamp=datetime.datetime.now(), 
                                  misconception=misconception, question_text=question_text, question_options=question_options, correct_answer=correct_answer,
                                  question_type=questiontype, mp_class=mp_class, exercise=exercise, course=course)
            self.record(log)

    
    def getUserLogs(self, userId, lookback_days=30):
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")

        with self.Session() as session:
            lookback_date = datetime.datetime.now() - datetime.timedelta(days=lookback_days)
            logs = session.query(StudentResponse).filter(StudentResponse.user_id == userId, StudentResponse.timestamp >= lookback_date).all()
            return logs


    def recordGeneratedExercise(self, userId, exercise_data, exercise_name):
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")
        if not isinstance(exercise_data, str):
            raise ValueError("exercise_data should be a string")
        
        log = GeneratedExercise(user_id=userId, timestamp=datetime.datetime.now(), exercise_data=exercise_data, exerciseName=exercise_name)
        self.record(log)



    def recordEnglishLTLPair(self, e_l_pair):

        if not isinstance(e_l_pair, dict):
            raise ValueError("e_l_pair should be a dictionary")
        
        if 'english' not in e_l_pair or 'ltl' not in e_l_pair:
            raise ValueError("e_l_pair should contain 'english' and 'ltl' keys")
        
        english = e_l_pair['english']
        ltl = e_l_pair['ltl']
        comments = e_l_pair['comments']
        userId = e_l_pair['user_id']


        log = EnglishLTLRating(english=english, ltl=ltl, comments=comments, user_id=userId)
        self.record(log)

    def logSentencePairRating(self, rating_data):
        """Insert or update a user's rating for a specific benchmark row."""
        required = ['user_id', 'dataset', 'row_index', 'likert_rating']
        for key in required:
            if key not in rating_data:
                raise ValueError(f"rating_data missing required key '{key}'")

        with self.Session() as session:
            existing = session.query(SentencePairRating).filter(
                SentencePairRating.user_id == rating_data['user_id'],
                SentencePairRating.dataset == rating_data['dataset'],
                SentencePairRating.row_index == rating_data['row_index']
            ).one_or_none()

            if existing:
                existing.likert_rating = rating_data['likert_rating']
                existing.awkward_flag = rating_data.get('awkward_flag', False)
                existing.awkward_notes = rating_data.get('awkward_notes', '')
                existing.base_english = rating_data.get('base_english', existing.base_english)
                existing.mutant_english = rating_data.get('mutant_english', existing.mutant_english)
                existing.base_ltl = rating_data.get('base_ltl', existing.base_ltl)
                existing.mutant_ltl = rating_data.get('mutant_ltl', existing.mutant_ltl)
                existing.misconception = rating_data.get('misconception', existing.misconception)
                existing.closest_distance = rating_data.get('closest_distance', existing.closest_distance)
                existing.max_distance = rating_data.get('max_distance', existing.max_distance)
                existing.avg_distance = rating_data.get('avg_distance', existing.avg_distance)
                existing.num_mutants = rating_data.get('num_mutants', existing.num_mutants)
            else:
                log = SentencePairRating(
                    user_id=rating_data['user_id'],
                    dataset=rating_data['dataset'],
                    row_index=rating_data['row_index'],
                    base_english=rating_data.get('base_english', ''),
                    mutant_english=rating_data.get('mutant_english', ''),
                    base_ltl=rating_data.get('base_ltl', ''),
                    mutant_ltl=rating_data.get('mutant_ltl', ''),
                    misconception=rating_data.get('misconception', ''),
                    likert_rating=rating_data['likert_rating'],
                    awkward_flag=rating_data.get('awkward_flag', False),
                    awkward_notes=rating_data.get('awkward_notes', ''),
                    closest_distance=rating_data.get('closest_distance'),
                    max_distance=rating_data.get('max_distance'),
                    avg_distance=rating_data.get('avg_distance'),
                    num_mutants=rating_data.get('num_mutants')
                )
                session.add(log)

            session.commit()

    def getRatedSentencePairIndices(self, user_id, dataset):
        """Return a set of row indices already rated by the user for the dataset."""
        if not isinstance(user_id, str):
            raise ValueError("user_id should be a string")
        if not isinstance(dataset, str):
            raise ValueError("dataset should be a string")

        with self.Session() as session:
            rows = session.query(SentencePairRating.row_index).filter(
                SentencePairRating.user_id == user_id,
                SentencePairRating.dataset == dataset
            ).all()
            return {row[0] for row in rows}


    def getComplexity(self, userId):
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")

        with self.Session() as session:
            complexity = session.query(GeneratedExercise.complexity).filter(GeneratedExercise.user_id == userId).order_by(GeneratedExercise.timestamp.desc()).first()
            return complexity[0] if complexity else None
    

    def getUserExercises(self, userId, lookback_days=30):
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")

        with self.Session() as session:
            lookback_date = datetime.datetime.now() - datetime.timedelta(days=lookback_days)
            logs = session.query(GeneratedExercise).filter(GeneratedExercise.user_id == userId, GeneratedExercise.timestamp >= lookback_date).all()
            return logs
        
    def getCourseResponses(self, course_name):
        if not isinstance(course_name, str):
            raise ValueError("exercise_name should be a string")

        with self.Session() as session:
            student_responses = session.query(StudentResponse).filter(StudentResponse.course == course_name).all()
            return student_responses
    
    def getUserExerciseResponses(self, userId, exercise_name):
        """Get the number of unique questions answered by a user for a specific exercise."""
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")
        if not isinstance(exercise_name, str):
            raise ValueError("exercise_name should be a string")

        with self.Session() as session:
            # Count distinct question_text entries for this user/exercise combo
            from sqlalchemy import func
            count = session.query(func.count(func.distinct(StudentResponse.question_text))).filter(
                StudentResponse.user_id == userId,
                StudentResponse.exercise == exercise_name
            ).scalar()
            return count or 0
    
    def getCompletedExercises(self, userId, exercise_names_and_counts):
        """Given a list of (exercise_name, question_count) tuples, return which ones the user has completed."""
        if not isinstance(userId, str):
            raise ValueError("userId should be a string")
        
        completed = set()
        for exercise_name, question_count in exercise_names_and_counts:
            answered = self.getUserExerciseResponses(userId, exercise_name)
            if answered >= question_count:
                completed.add(exercise_name)
        return completed
    
